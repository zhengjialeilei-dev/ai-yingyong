<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Three.js æ‰‹åŠ¿äº¤äº’ç²’å­ç³»ç»Ÿ - å¥‡å¼‚åšå£«ç‰ˆ</title>
    <style>
        :root {
            --primary-color: #ffaa00;
            --glass-bg: rgba(20, 20, 30, 0.8);
            --border-color: rgba(255, 255, 255, 0.1);
        }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        
        /* å…¨å± Canvas */
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* æ˜¾ç¤ºæ‘„åƒå¤´è§†é¢‘æºï¼Œæ–¹ä¾¿ç”¨æˆ·æŸ¥çœ‹æ‰‹åŠ¿ */
        #input-video { 
            position: absolute; 
            bottom: 20px; 
            right: 20px; 
            width: 240px; 
            height: 180px; 
            border-radius: 8px; 
            border: 2px solid rgba(255, 170, 0, 0.5); 
            z-index: 5; 
            background: #333;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
            object-fit: cover;
        }

        /* UI ä¾§è¾¹æ  */
        #ui-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 280px;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            color: white;
            z-index: 10;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }

        h2 { margin: 0 0 15px 0; font-size: 18px; color: var(--primary-color); text-transform: uppercase; letter-spacing: 1px; }
        
        .control-group { margin-bottom: 15px; }
        .control-group label { display: block; margin-bottom: 5px; font-size: 12px; color: #aaa; }
        
        /* çŠ¶æ€æ˜¾ç¤º */
        #status-display {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 6px;
            font-family: monospace;
            color: #00ff88;
            margin-bottom: 15px;
            border-left: 3px solid #00ff88;
        }

        /* é¢œè‰²é€‰æ‹©å™¨ */
        input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: none;
        }

        /* æŒ‰é’® */
        button {
            width: 100%;
            padding: 10px;
            background: linear-gradient(45deg, #ff6b00, #ffaa00);
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
        }
        button:hover { transform: scale(1.02); }

        /* åŠ è½½é®ç½© */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: var(--primary-color);
            display: flex; justify-content: center; align-items: center;
            z-index: 100; font-size: 24px; flex-direction: column;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <div>æ­£åœ¨åˆå§‹åŒ–è§†è§‰ç¥ç»ä¸­æ¢...</div>
        <div style="font-size: 14px; margin-top: 10px; color: #666;">è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>
    </div>

    <video id="input-video"></video>
    <div id="canvas-container"></div>

    <aside id="ui-panel">
        <h2>ç²’å­æ§åˆ¶æ ¸å¿ƒ</h2>
        
        <div id="status-display">ç­‰å¾…æ‰‹åŠ¿è¾“å…¥...</div>

        <div class="control-group">
            <label>ç²’å­åŸºè°ƒè‰² (RGB/HEX)</label>
            <input type="color" id="color-picker" value="#ffaa00">
        </div>

        <div class="control-group">
            <button id="fullscreen-btn">åˆ‡æ¢å…¨å±æ²‰æµ¸æ¨¡å¼</button>
        </div>
        
        <div style="font-size: 12px; color: #666; margin-top: 20px;">
            æ“ä½œæŒ‡å—:<br>
            âœŠ æ¡æ‹³: èšèƒ½/åŠ é€Ÿ<br>
            ğŸ– å¼ å¼€: æ‰©æ•£/å‡é€Ÿ<br>
            ğŸ™ åŒæ‰‹åˆå: å¬å”¤é­”æ³•é˜µ
        </div>
    </aside>

<script>
/**
 * æ¨¡å—ä¸€ï¼šç²’å­ä¸3Dä¸–ç•Œç®¡ç† (Particle System Logic)
 */
class ParticleWorld {
    constructor(container) {
        this.container = container;
        this.params = {
            baseColor: new THREE.Color(0xffaa00),
            particleCount: 15000,
            magicRadius: 0, // åŠ¨æ€å˜åŒ–çš„åŠå¾„
            rotationSpeed: 0.002,
            targetSpeed: 0.002,
            targetSpread: 20,
            currentSpread: 20,
            currentShape: 'sphere', // é»˜è®¤å½¢çŠ¶ï¼šçƒä½“
            transitionProgress: 0,   // è¿‡æ¸¡è¿›åº¦ (0-1)
            transitionInProgress: false, // æ˜¯å¦æ­£åœ¨è¿‡æ¸¡
            targetShape: 'sphere'    // ç›®æ ‡å½¢çŠ¶
        };
        
        // å­˜å‚¨ä¸Šä¸€å¸§çš„ç²’å­ä½ç½®ï¼Œç”¨äºå¹³æ»‘è¿‡æ¸¡
        this.previousPositions = null;
        
        this.init();
        this.createParticles();
        this.createMagicCircle();
        this.animate();
    }

    init() {
        // åœºæ™¯ã€ç›¸æœºã€æ¸²æŸ“å™¨
        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.FogExp2(0x000000, 0.02);

        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.z = 50;

        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.container.appendChild(this.renderer.domElement);

        window.addEventListener('resize', () => this.onWindowResize(), false);
    }

    createParticles() {
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const sizes = [];

        const color = new THREE.Color();

        // æ ¹æ®å½“å‰å½¢çŠ¶ç”Ÿæˆç²’å­ä½ç½®
        for (let i = 0; i < this.params.particleCount; i++) {
            let x, y, z;
            
            // æ ¹æ®å½“å‰å½¢çŠ¶é€‰æ‹©ç”Ÿæˆæ–¹æ³•
            switch(this.params.currentShape) {
                case 'cube':
                    [x, y, z] = this.generateCubeParticle(i);
                    break;
                case 'cylinder':
                    [x, y, z] = this.generateCylinderParticle(i);
                    break;
                case 'torus':
                    [x, y, z] = this.generateTorusParticle(i);
                    break;
                case 'spiral':
                    [x, y, z] = this.generateSpiralParticle(i);
                    break;
                case 'sphere':
                default:
                    [x, y, z] = this.generateSphereParticle(i);
            }

            positions.push(x, y, z);
            color.set(this.params.baseColor);
            colors.push(color.r, color.g, color.b);
            sizes.push(Math.random() * 0.5);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

        // ç®€å•çš„åœ†å½¢çº¹ç†æ¨¡æ‹Ÿ
        const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');

        this.material = new THREE.PointsMaterial({
            size: 0.5,
            map: sprite,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true,
            opacity: 0.8
        });

        // å¦‚æœå·²å­˜åœ¨ç²’å­ç³»ç»Ÿï¼Œå…ˆç§»é™¤
        if (this.particleSystem) {
            this.scene.remove(this.particleSystem);
        }

        this.particleSystem = new THREE.Points(geometry, this.material);
        this.scene.add(this.particleSystem);
    }
    
    // ç”Ÿæˆçƒä½“ç²’å­ - å¯¹åº”5æ ¹æ‰‹æŒ‡
    generateSphereParticle(index) {
        const r = (Math.random() * 30) + 10;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        
        return [
            r * Math.sin(phi) * Math.cos(theta),
            r * Math.sin(phi) * Math.sin(theta),
            r * Math.cos(phi)
        ];
    }
    
    // ç”Ÿæˆç«‹æ–¹ä½“ç²’å­ - å¯¹åº”4æ ¹æ‰‹æŒ‡
    generateCubeParticle(index) {
        const size = 30;
        return [
            (Math.random() - 0.5) * size * 2,
            (Math.random() - 0.5) * size * 2,
            (Math.random() - 0.5) * size * 2
        ];
    }
    
    // ç”Ÿæˆåœ†æŸ±ä½“ç²’å­ - å¯¹åº”3æ ¹æ‰‹æŒ‡
    generateCylinderParticle(index) {
        const radius = (Math.random() * 20) + 5;
        const height = (Math.random() - 0.5) * 40;
        const theta = Math.random() * Math.PI * 2;
        
        return [
            radius * Math.cos(theta),
            height,
            radius * Math.sin(theta)
        ];
    }
    
    // ç”Ÿæˆåœ†ç¯ç²’å­ - å¯¹åº”2æ ¹æ‰‹æŒ‡
    generateTorusParticle(index) {
        const majorRadius = 20;
        const minorRadius = 8;
        const u = Math.random() * Math.PI * 2;
        const v = Math.random() * Math.PI * 2;
        
        return [
            (majorRadius + minorRadius * Math.cos(v)) * Math.cos(u),
            minorRadius * Math.sin(v),
            (majorRadius + minorRadius * Math.cos(v)) * Math.sin(u)
        ];
    }
    
    // ç”Ÿæˆèºæ—‹çº¿ç²’å­ - åŸå‡½æ•°ä¿ç•™
    generateSpiralParticle(index) {
        const t = Math.random() * 10 * Math.PI;
        const radius = 15 + Math.sin(t * 0.5) * 5;
        
        return [
            radius * Math.cos(t),
            t * 2 - 30,
            radius * Math.sin(t)
        ];
    }
    
    // ç”Ÿæˆå›¾è…¾å½¢çŠ¶ç²’å­ - å¯¹åº”1æ ¹æ‰‹æŒ‡
    generateTotemParticle(index) {
        // åˆ›å»ºä¸€ä¸ªæœ‰å±‚æ¬¡æ„Ÿçš„å›¾è…¾å½¢çŠ¶
        // 1. ä¸­å¿ƒéƒ¨åˆ†ï¼šæŸ±çŠ¶ç»“æ„
        // 2. ä¸­é—´éƒ¨åˆ†ï¼šç¯çŠ¶è£…é¥°
        // 3. é¡¶éƒ¨éƒ¨åˆ†ï¼šå°–å¡”çŠ¶
        
        const progress = index / this.params.particleCount;
        let x, y, z;
        
        // æ ¹æ®ç²’å­ç´¢å¼•å†³å®šä½ç½®ï¼Œåˆ›å»ºåˆ†å±‚ç»“æ„
        if (progress < 0.4) { // åº•éƒ¨æŸ±çŠ¶ç»“æ„
            const height = Math.random() * 40 - 20; // -20 åˆ° 20
            const radius = 8 + Math.sin(height * 0.2) * 2;
            const angle = Math.random() * Math.PI * 2;
            
            x = radius * Math.cos(angle);
            y = height;
            z = radius * Math.sin(angle);
        } else if (progress < 0.7) { // ä¸­é—´ç¯çŠ¶è£…é¥°
            const height = (Math.random() * 10) + 15; // 15 åˆ° 25
            const ringRadius = 12 + Math.sin(Math.random() * Math.PI * 2) * 3;
            const angle = Math.random() * Math.PI * 2;
            
            x = ringRadius * Math.cos(angle);
            y = height;
            z = ringRadius * Math.sin(angle);
        } else if (progress < 0.9) { // ä¸Šéƒ¨è£…é¥°
            const height = (Math.random() * 10) + 25; // 25 åˆ° 35
            const radius = 5 + Math.sin(Math.random() * Math.PI * 2) * 2;
            const angle = Math.random() * Math.PI * 2;
            
            x = radius * Math.cos(angle);
            y = height;
            z = radius * Math.sin(angle);
        } else { // é¡¶éƒ¨å°–å¡”
            const height = (Math.random() * 10) + 35; // 35 åˆ° 45
            const radius = 3 - (height - 35) / 10 * 2; // ä»3æ¸å˜åˆ°1
            const angle = Math.random() * Math.PI * 2;
            
            x = radius * Math.cos(angle);
            y = height;
            z = radius * Math.sin(angle);
        }
        
        return [x, y, z];
    }
    
    // ç”Ÿæˆæ˜Ÿå½¢ç²’å­
    generateStarParticle(index) {
        const spikes = 5;
        const outerRadius = 20;
        const innerRadius = 8;
        const rotation = Math.random() * Math.PI * 2;
        const angle = (Math.random() * Math.PI * 2) + rotation;
        const r = (Math.floor(Math.random() * 2) === 0) ? outerRadius : innerRadius;
        
        return [
            r * Math.cos(angle),
            r * Math.sin(angle),
            (Math.random() - 0.5) * 10
        ];
    }
    
    // ç”Ÿæˆåœ†é”¥ä½“ç²’å­
    generateConeParticle(index) {
        const height = 30;
        const radius = Math.random() * 15;
        const y = Math.random() * height - height/2;
        const coneRadius = radius * (1 - (y + height/2) / height);
        const angle = Math.random() * Math.PI * 2;
        
        return [
            coneRadius * Math.cos(angle),
            y,
            coneRadius * Math.sin(angle)
        ];
    }
    
    // ç”Ÿæˆå››é¢ä½“ç²’å­
    generateTetrahedronParticle(index) {
        // å››é¢ä½“çš„å››ä¸ªé¡¶ç‚¹
        const vertices = [
            [1, 1, 1],
            [-1, -1, 1],
            [-1, 1, -1],
            [1, -1, -1]
        ];
        
        // éšæœºé€‰æ‹©ä¸€ä¸ªé¢
        const faceIndex = Math.floor(Math.random() * 4);
        const vertex1 = vertices[faceIndex];
        const vertex2 = vertices[(faceIndex + 1) % 4];
        const vertex3 = vertices[(faceIndex + 2) % 4];
        
        // åœ¨é¢ä¸Šéšæœºç”Ÿæˆç‚¹
        const u = Math.random();
        const v = Math.random() * (1 - u);
        const w = 1 - u - v;
        
        const scale = 20;
        return [
            (vertex1[0] * u + vertex2[0] * v + vertex3[0] * w) * scale,
            (vertex1[1] * u + vertex2[1] * v + vertex3[1] * w) * scale,
            (vertex1[2] * u + vertex2[2] * v + vertex3[2] * w) * scale
        ];
    }
    
    // ç”ŸæˆåŒæ›²çº¿ç²’å­
    generateHyperbolaParticle(index) {
        const t = (Math.random() - 0.5) * 10;
        const a = 8; // åŠå®è½´
        const b = 5; // åŠè™šè½´
        
        // åŒæ›²çº¿çš„ä¸€æ”¯
        const x = a * Math.cosh(t);
        const y = b * Math.sinh(t);
        const z = (Math.random() - 0.5) * 10;
        
        // 50%æ¦‚ç‡ç”Ÿæˆå¦ä¸€æ”¯
        const branch = Math.random() > 0.5 ? 1 : -1;
        
        return [
            x * branch,
            y,
            z
        ];
    }
    
    // åˆ‡æ¢ç²’å­å½¢çŠ¶ï¼Œå¸¦å¹³æ»‘è¿‡æ¸¡
    setParticleShape(shape) {
        // å¦‚æœå½“å‰æ­£åœ¨è¿‡æ¸¡æˆ–è€…å½¢çŠ¶æ²¡æœ‰å˜åŒ–ï¼Œåˆ™ä¸æ‰§è¡Œ
        if (this.params.transitionInProgress || this.params.currentShape === shape) {
            return;
        }
        
        // ä¿å­˜å½“å‰ç²’å­ä½ç½®ç”¨äºè¿‡æ¸¡
        if (this.particleSystem) {
            this.previousPositions = [...this.particleSystem.geometry.attributes.position.array];
        }
        
        // è®¾ç½®è¿‡æ¸¡çŠ¶æ€
        this.params.targetShape = shape;
        this.params.transitionProgress = 0;
        this.params.transitionInProgress = true;
        
        // åˆ›å»ºç›®æ ‡å½¢çŠ¶çš„ä¸´æ—¶ç²’å­ä½ç½®
        this.targetPositions = [];
        for (let i = 0; i < this.params.particleCount; i++) {
            let x, y, z;
            
            // æ ¹æ®ç›®æ ‡å½¢çŠ¶ç”Ÿæˆä½ç½®
            switch(shape) {
                case 'cube':
                    [x, y, z] = this.generateCubeParticle(i);
                    break;
                case 'cylinder':
                    [x, y, z] = this.generateCylinderParticle(i);
                    break;
                case 'torus':
                    [x, y, z] = this.generateTorusParticle(i);
                    break;
                case 'totem':
                    [x, y, z] = this.generateTotemParticle(i);
                    break;
                case 'star':
                    [x, y, z] = this.generateStarParticle(i);
                    break;
                case 'cone':
                    [x, y, z] = this.generateConeParticle(i);
                    break;
                case 'tetrahedron':
                    [x, y, z] = this.generateTetrahedronParticle(i);
                    break;
                case 'hyperbola':
                    [x, y, z] = this.generateHyperbolaParticle(i);
                    break;
                case 'sphere':
                default:
                    [x, y, z] = this.generateSphereParticle(i);
            }
            
            this.targetPositions.push(x, y, z);
        }
    }
    
    // æ›´æ–°è¿‡æ¸¡åŠ¨ç”»
    updateTransition() {
        if (!this.params.transitionInProgress || !this.previousPositions || !this.targetPositions) {
            return;
        }
        
        // ä½¿ç”¨æ›´æ…¢çš„è¿‡æ¸¡é€Ÿåº¦ï¼Œç¡®ä¿è¶³å¤Ÿå¹³æ»‘
        this.params.transitionProgress += 0.008; // è¿›ä¸€æ­¥é™ä½é€Ÿåº¦åˆ°0.008
        
        if (this.params.transitionProgress >= 1.0) {
            // è¿‡æ¸¡å®Œæˆ
            this.params.transitionProgress = 0;
            this.params.transitionInProgress = false;
            if (this.params.targetShape) {
                this.params.currentShape = this.params.targetShape;
            }
            this.previousPositions = null;
            this.targetPositions = null;
            
            // åªæ›´æ–°å¿…è¦çš„å±æ€§
            this.particleSystem.geometry.attributes.position.needsUpdate = true;
        } else {
            // ä½¿ç”¨ä¼˜åŒ–åçš„easeInOutQuadå‡½æ•°ï¼Œæä¾›æ›´å¹³æ»‘çš„æ›²çº¿
            const easeProgress = this.easeInOutQuad(this.params.transitionProgress);
            
            // åº”ç”¨è¿‡æ¸¡åˆ°å½“å‰ç²’å­ä½ç½®
            const positions = this.particleSystem.geometry.attributes.position.array;
            
            // è¿›ä¸€æ­¥å‡å°‘éšæœºæ€§ï¼Œç¡®ä¿æ‰€æœ‰ç²’å­çš„è¿‡æ¸¡æ›´åŠ ä¸€è‡´
            for (let i = 0; i < positions.length; i += 3) {
                // å®Œå…¨ç§»é™¤éšæœºæ€§ï¼Œæ‰€æœ‰ç²’å­ä½¿ç”¨ç›¸åŒçš„è¿‡æ¸¡è¿›åº¦
                // è¿™æ ·å¯ä»¥æœ€å¤§ç¨‹åº¦å‡å°‘æŠ–åŠ¨
                const particleProgress = easeProgress;
                const clampedProgress = Math.max(0, Math.min(1, particleProgress));
                
                // ä½¿ç”¨lerpè®¡ç®—å¹³æ»‘è¿‡æ¸¡
                positions[i] = this.lerp(this.previousPositions[i], this.targetPositions[i], clampedProgress);
                positions[i+1] = this.lerp(this.previousPositions[i+1], this.targetPositions[i+1], clampedProgress);
                positions[i+2] = this.lerp(this.previousPositions[i+2], this.targetPositions[i+2], clampedProgress);
            }
            
            this.particleSystem.geometry.attributes.position.needsUpdate = true;
        }
    }
    
    // çº¿æ€§æ’å€¼è¾…åŠ©æ–¹æ³•ï¼Œç¡®ä¿è®¡ç®—ä¸€è‡´æ€§
    lerp(a, b, t) {
        return a + (b - a) * t;
    }
    
    // å¤šç§ç¼“åŠ¨å‡½æ•°
    
    // å…ˆæ…¢åå¿«
    easeInCubic(t) {
        return t * t * t;
    }
    
    // å…ˆå¿«åæ…¢
    easeOutQuart(t) {
        return 1 - Math.pow(1 - t, 4);
    }
    
    // æ­£å¼¦ç¼“åŠ¨ï¼Œå¹³æ»‘çš„åŠ é€Ÿå’Œå‡é€Ÿ
    easeInOutSine(t) {
        // æ”¹è¿›çš„ç¼“åŠ¨å‡½æ•°ï¼Œæä¾›æ›´è‡ªç„¶çš„å¹³æ»‘æ›²çº¿
        return -(Math.cos(Math.PI * t * 1.05) - 1) / 2 * 0.98 + 0.01 * t;
    }
    
    // æ›´å¹³æ»‘çš„easeInOutQuadå‡½æ•°
    easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    }
    
    // å¼¹æ€§ç¼“åŠ¨ï¼Œå¢åŠ ä¸€äº›å¼¹æ€§æ•ˆæœ
    easeOutElastic(t) {
        const c4 = (2 * Math.PI) / 3;
        
        return t === 0
            ? 0
            : t === 1
            ? 1
            : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
    }

    createMagicCircle() {
        // åˆ›å»ºå¥‡å¼‚åšå£«é£æ ¼çš„é­”æ³•é˜µç¯
        this.magicGroup = new THREE.Group();
        this.magicGroup.visible = false; // é»˜è®¤éšè—

        const createRing = (radius, count, width) => {
            const geom = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<count; i++) {
                const angle = (i / count) * Math.PI * 2;
                pos.push(
                    Math.cos(angle) * radius,
                    Math.sin(angle) * radius,
                    0
                );
            }
            geom.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({
                color: 0xff4400,
                size: width,
                blending: THREE.AdditiveBlending
            });
            return new THREE.Points(geom, mat);
        };

        // å¤æ‚çš„ç¯ç»“æ„
        this.ring1 = createRing(15, 200, 1.5); // å†…ç¯
        this.ring2 = createRing(22, 400, 1.0); // ä¸­ç¯
        this.ring3 = createRing(25, 100, 2.0); // ç¬¦æ–‡èŠ‚ç‚¹ç¯

        // æ–¹å—å‡ ä½•ä½“å¢åŠ é­”æ³•æ„Ÿ
        const geomSquare = new THREE.BoxGeometry(18, 18, 0.5);
        const matSquare = new THREE.MeshBasicMaterial({ color: 0xffaa00, wireframe: true, transparent: true, opacity: 0.3 });
        this.square = new THREE.Mesh(geomSquare, matSquare);

        this.magicGroup.add(this.ring1, this.ring2, this.ring3, this.square);
        this.scene.add(this.magicGroup);
    }

    updateParticles() {
        const positions = this.particleSystem.geometry.attributes.position.array;
        const time = Date.now() * 0.0005;

        // åˆå§‹åŒ–å‚æ•°ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
        if (this.params.rotationSpeed === undefined) this.params.rotationSpeed = 0.001;
        if (this.params.currentSpread === undefined) this.params.currentSpread = 10;
        
        // åŠ¨æ€è°ƒæ•´é€Ÿåº¦å’Œæ‰©æ•£åº¦ï¼Œä½¿ç”¨æ›´æ…¢çš„è¿‡æ¸¡é€Ÿç‡ä»¥å‡å°‘æŠ–åŠ¨
        const smoothFactor = 0.05; // é™ä½ä»0.1åˆ°0.05ï¼Œä½¿è¿‡æ¸¡æ›´å¹³æ»‘
        this.params.rotationSpeed += (this.params.targetSpeed - this.params.rotationSpeed) * smoothFactor;
        this.params.currentSpread += (this.params.targetSpread - this.params.currentSpread) * smoothFactor;
        
        // æ›´æ–°è¿‡æ¸¡åŠ¨ç”»
        this.updateTransition();

        // æ•´ä½“æ—‹è½¬
        this.particleSystem.rotation.y += this.params.rotationSpeed;
        this.particleSystem.rotation.z += this.params.rotationSpeed * 0.5;

        // é­”æ³•é˜µåŠ¨ç”»
        if(this.magicGroup.visible) {
            this.magicGroup.rotation.z -= 0.02;
            this.ring1.rotation.z += 0.04;
            this.ring2.rotation.z -= 0.01;
            this.square.rotation.z += 0.01;
            
            // è„‰å†²æ•ˆæœ
            const scale = 1 + Math.sin(time * 5) * 0.05;
            this.magicGroup.scale.set(scale, scale, scale);
        }
    }

    setInteractionState(state) {
        // åˆå§‹åŒ–å‚æ•°å¹³æ»‘è¿‡æ¸¡å˜é‡ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
        if (!this.paramTransitionInProgress) {
            this.paramTransitionInProgress = false;
            this.targetColorIntensity = this.params.colorIntensity || 1.0;
        }
        
        // å¹³æ»‘è¿‡æ¸¡é¢œè‰²å¼ºåº¦çš„è¾…åŠ©å‡½æ•°
        const smoothColorIntensity = (newIntensity) => {
            this.targetColorIntensity = newIntensity;
            this.paramTransitionInProgress = true;
        };
        
        // å¤„ç†å›¾å½¢åˆ‡æ¢çŠ¶æ€ (SWITCH_SHAPE_X)
        if (state.startsWith('SWITCH_SHAPE_')) {
            // å®šä¹‰å¯ç”¨çš„å½¢çŠ¶åˆ—è¡¨ï¼ŒåŒ…å«æ–°å¢çš„å›¾å½¢
            const shapes = ['totem', 'torus', 'cylinder', 'cube', 'sphere', 'star', 'cone', 'tetrahedron', 'hyperbola'];
            const speeds = [0.015, 0.012, 0.01, 0.008, 0.005, 0.018, 0.013, 0.009, 0.02];
            
            // è·å–å½“å‰åˆ‡æ¢æ¬¡æ•°
            const switchCount = parseInt(state.split('_')[2]);
            // è®¡ç®—å½¢çŠ¶ç´¢å¼•ï¼ˆå¾ªç¯ä½¿ç”¨å½¢çŠ¶åˆ—è¡¨ï¼‰
            const shapeIndex = (switchCount - 1) % shapes.length;
            
            // è®¾ç½®å¯¹åº”çš„å½¢çŠ¶å’Œå‚æ•°
            this.setParticleShape(shapes[shapeIndex]);
            this.params.targetSpeed = speeds[shapeIndex];
            this.params.targetSpread = 25;
            
            // å¹³æ»‘è¿‡æ¸¡åˆ°æ–°çŠ¶æ€
            this.startStateTransition();
            this.magicGroup.visible = false;
            smoothColorIntensity(1.0);
            return;
        }
        
        // åŸæœ‰çŠ¶æ€å¤„ç†: 'FIST', 'OPEN', 'MAGIC', 'IDLE'
        switch(state) {
            case 'FIST':
                // å½“åˆ‡æ¢åˆ°FISTçŠ¶æ€æ—¶ï¼Œä¿å­˜å½“å‰ä½ç½®å¹¶åˆ›å»ºå‘ä¸­å¿ƒç‚¹æ”¶ç¼©çš„å¹³æ»‘è¿‡æ¸¡
                if (this.particleSystem && !this.params.transitionInProgress) {
                    this.previousPositions = [...this.particleSystem.geometry.attributes.position.array];
                    
                    // åˆ›å»ºå‘ä¸­å¿ƒç‚¹æ”¶ç¼©çš„ç›®æ ‡ä½ç½®
                    this.targetPositions = [];
                    for (let i = 0; i < this.params.particleCount; i++) {
                        // æ¯ä¸ªç²’å­å‘åŸç‚¹æ”¶ç¼©ï¼Œä½†ä¿ç•™ä¸€äº›éšæœºæ€§
                        const angle = (i / this.params.particleCount) * Math.PI * 2;
                        const radius = 5 + Math.random() * 10;
                        this.targetPositions.push(
                            Math.cos(angle) * radius,
                            Math.sin(angle) * radius,
                            (Math.random() - 0.5) * 10
                        );
                    }
                    
                    // å¯åŠ¨è¿‡æ¸¡
                    this.params.transitionProgress = 0;
                    this.params.transitionInProgress = true;
                }
                
                this.params.targetSpeed = 0.05; // é«˜é€Ÿæ—‹è½¬
                this.params.targetSpread = 5;   // æ”¶ç¼©
                this.magicGroup.visible = false;
                smoothColorIntensity(1.5);
                break;
            case 'OPEN':
                // å½“åˆ‡æ¢åˆ°OPENçŠ¶æ€æ—¶ï¼Œä»å½“å‰çŠ¶æ€å¹³æ»‘è¿‡æ¸¡
                if (this.particleSystem && !this.params.transitionInProgress) {
                    this.previousPositions = [...this.particleSystem.geometry.attributes.position.array];
                    
                    // åˆ›å»ºæ‰©æ•£ä½†ä¿æŒå½¢çŠ¶ç‰¹å¾çš„ç›®æ ‡ä½ç½®
                    this.targetPositions = [];
                    for (let i = 0; i < this.params.particleCount; i++) {
                        let x, y, z;
                        
                        // å¦‚æœå½“å‰æœ‰å½¢çŠ¶ï¼Œå°è¯•ä¿æŒå…¶ç‰¹æ€§åŒæ—¶æ‰©æ•£
                        if (this.params.currentShape) {
                            switch(this.params.currentShape) {
                                case 'cube':
                                    [x, y, z] = this.generateCubeParticle(i);
                                    break;
                                case 'cylinder':
                                    [x, y, z] = this.generateCylinderParticle(i);
                                    break;
                                case 'torus':
                                    [x, y, z] = this.generateTorusParticle(i);
                                    break;
                                case 'totem':
                                    [x, y, z] = this.generateTotemParticle(i);
                                    break;
                                case 'star':
                                    [x, y, z] = this.generateStarParticle(i);
                                    break;
                                case 'cone':
                                    [x, y, z] = this.generateConeParticle(i);
                                    break;
                                case 'tetrahedron':
                                    [x, y, z] = this.generateTetrahedronParticle(i);
                                    break;
                                case 'hyperbola':
                                    [x, y, z] = this.generateHyperbolaParticle(i);
                                    break;
                                case 'sphere':
                                default:
                                    [x, y, z] = this.generateSphereParticle(i);
                            }
                        } else {
                            // å¦‚æœæ²¡æœ‰å½“å‰å½¢çŠ¶ï¼Œç”Ÿæˆä¸€ä¸ªæ‰©æ•£çš„çƒå½¢
                            [x, y, z] = this.generateSphereParticle(i);
                        }
                        
                        // æ·»åŠ ä¸€äº›éšæœºæ€§ä½¿æ‰©æ•£æ›´è‡ªç„¶
                        x += (Math.random() - 0.5) * 10;
                        y += (Math.random() - 0.5) * 10;
                        z += (Math.random() - 0.5) * 10;
                        
                        this.targetPositions.push(x, y, z);
                    }
                    
                    // å¯åŠ¨è¿‡æ¸¡
                    this.params.transitionProgress = 0;
                    this.params.transitionInProgress = true;
                }
                
                this.params.targetSpeed = 0.008; // ä¸­ç­‰é€Ÿåº¦
                this.params.targetSpread = 25;   // é€‚ä¸­çš„æ‰©æ•£
                this.magicGroup.visible = false;
                smoothColorIntensity(1.0); // ä¿æŒæ­£å¸¸çš„é¢œè‰²å¼ºåº¦
                break;
            case 'MAGIC':
                // å½“åˆ‡æ¢åˆ°MAGICçŠ¶æ€æ—¶ï¼Œåˆ›å»ºåˆ°é­”æ³•é˜µå½¢çŠ¶çš„å¹³æ»‘è¿‡æ¸¡
                if (this.particleSystem && !this.params.transitionInProgress) {
                    this.previousPositions = [...this.particleSystem.geometry.attributes.position.array];
                    
                    // åˆ›å»ºé­”æ³•é˜µç›¸å…³çš„ç›®æ ‡ä½ç½®
                    this.targetPositions = [];
                    for (let i = 0; i < this.params.particleCount; i++) {
                        // ç”Ÿæˆå›´ç»•é­”æ³•é˜µåˆ†å¸ƒçš„ç²’å­
                        const angle = (i / this.params.particleCount) * Math.PI * 2;
                        const radius = 30 + Math.sin(i * 0.5) * 15 + Math.random() * 20;
                        this.targetPositions.push(
                            Math.cos(angle) * radius,
                            Math.sin(angle) * radius,
                            (Math.random() - 0.5) * 20 + Math.sin(i * 0.3) * 10
                        );
                    }
                    
                    // å¯åŠ¨è¿‡æ¸¡
                    this.params.transitionProgress = 0;
                    this.params.transitionInProgress = true;
                }
                
                this.params.targetSpeed = 0.01;
                this.params.targetSpread = 25;
                this.magicGroup.visible = true; // æ¿€æ´»é­”æ³•é˜µ
                break;
            default: // IDLEçŠ¶æ€
                // å½“åˆ‡æ¢åˆ°IDLEçŠ¶æ€æ—¶ï¼Œåˆ›å»ºåˆ°è‡ªç„¶æ‰©æ•£çš„å¹³æ»‘è¿‡æ¸¡
                if (this.particleSystem && !this.params.transitionInProgress) {
                    this.previousPositions = [...this.particleSystem.geometry.attributes.position.array];
                    
                    // åˆ›å»ºè‡ªç„¶æ‰©æ•£çš„ç›®æ ‡ä½ç½®
                    this.targetPositions = [];
                    for (let i = 0; i < this.params.particleCount; i++) {
                        // ç”Ÿæˆä¸€ä¸ªå‡åŒ€åˆ†å¸ƒçš„çƒå½¢
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.random() * Math.PI;
                        const radius = 20 + Math.random() * 30;
                        this.targetPositions.push(
                            radius * Math.sin(phi) * Math.cos(theta),
                            radius * Math.sin(phi) * Math.sin(theta),
                            radius * Math.cos(phi)
                        );
                    }
                    
                    // å¯åŠ¨è¿‡æ¸¡
                    this.params.transitionProgress = 0;
                    this.params.transitionInProgress = true;
                }
                
                this.params.targetSpeed = 0.005;
                this.params.targetSpread = 20;
                this.magicGroup.visible = false;
        }
    }
    
    // å¼€å§‹çŠ¶æ€è¿‡æ¸¡çš„è¾…åŠ©æ–¹æ³•
    startStateTransition() {
        if (this.particleSystem && !this.params.transitionInProgress) {
            // ç¡®ä¿å·²ç»è®¾ç½®äº†previousPositions
            if (!this.previousPositions) {
                this.previousPositions = [...this.particleSystem.geometry.attributes.position.array];
            }
        }
    }

    setColor(hexString) {
        const c = new THREE.Color(hexString);
        this.params.baseColor = c;
        const colors = this.particleSystem.geometry.attributes.color.array;
        for (let i = 0; i < colors.length; i += 3) {
            colors[i] = c.r;
            colors[i+1] = c.g;
            colors[i+2] = c.b;
        }
        this.particleSystem.geometry.attributes.color.needsUpdate = true;
        
        // æ›´æ–°é­”æ³•é˜µé¢œè‰²
        this.magicGroup.children.forEach(child => {
             if(child.material) child.material.color.set(c);
        });
    }

    updateColorIntensity(intensity) {
        this.material.opacity = Math.min(0.8 * intensity, 1.0);
    }

    onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // æ›´æ–°å‚æ•°å¹³æ»‘è¿‡æ¸¡
    updateParamTransitions() {
        if (!this.paramTransitionInProgress) return;
        
        // ä½¿ç”¨å¹³æ»‘çš„è¿‡æ¸¡é€Ÿç‡æ›´æ–°å‚æ•°
        const transitionSpeed = 0.05; // å‚æ•°è¿‡æ¸¡é€Ÿåº¦
        
        // å¹³æ»‘æ›´æ–°é¢œè‰²å¼ºåº¦
        if (this.params.colorIntensity !== undefined && this.targetColorIntensity !== undefined) {
            this.params.colorIntensity = this.lerp(this.params.colorIntensity, this.targetColorIntensity, transitionSpeed);
            this.updateColorIntensity(this.params.colorIntensity);
            
            // æ£€æŸ¥æ˜¯å¦å®Œæˆè¿‡æ¸¡
            if (Math.abs(this.params.colorIntensity - this.targetColorIntensity) < 0.001) {
                this.paramTransitionInProgress = false;
            }
        }
    }
    
    animate() {
        requestAnimationFrame(() => this.animate());
        this.updateParticles();
        this.updateParamTransitions(); // æ›´æ–°å‚æ•°å¹³æ»‘è¿‡æ¸¡
        this.renderer.render(this.scene, this.camera);
    }
}

/**
 * æ¨¡å—äºŒï¼šæ‰‹åŠ¿è¯†åˆ« (Hand Tracking Logic)
 */
class HandController {
    constructor(videoElement, onStateChange) {
        this.video = videoElement;
        this.onStateChange = onStateChange;
        this.currentState = 'IDLE';
        this.lastState = 'IDLE';
        this.fistCount = 0; // æ¡æ‹³æ¬¡æ•°è®¡æ•°å™¨
        this.wasFist = false; // è®°å½•ä¸Šä¸€å¸§æ˜¯å¦ä¸ºæ¡æ‹³çŠ¶æ€

        this.hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        this.hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.6
        });

        this.hands.onResults((results) => this.processResults(results));

        this.camera = new Camera(this.video, {
            onFrame: async () => {
                await this.hands.send({image: this.video});
            },
            width: 640,
            height: 480
        });
    }

    start() {
        this.camera.start()
            .then(() => document.getElementById('loader').style.display = 'none')
            .catch(e => console.error("Camera failed", e));
    }

    processResults(results) {
        let newState = 'IDLE';
        const landmarks = results.multiHandLandmarks;

        if (landmarks && landmarks.length > 0) {
            // æ£€æµ‹åŒæ‰‹
            if (landmarks.length === 2) {
                if (this.isHandsTogether(landmarks[0], landmarks[1])) {
                    newState = 'MAGIC';
                }
            } 
            
            // å¦‚æœä¸æ˜¯åŒæ‰‹çš„ç‰¹æ®ŠåŠ¨ä½œï¼Œæ£€æµ‹å•æ‰‹åŠ¨ä½œ
            if (newState !== 'MAGIC') {
                const hand = landmarks[0];
                
                // æ¡æ‹³æ£€æµ‹å’ŒçŠ¶æ€ç®¡ç†
                const isCurrentlyFist = this.isFist(hand);
                
                // æ£€æµ‹å®Œæ•´çš„æ¡æ‹³-æ¾å¼€åŠ¨ä½œï¼šå…ˆæ¡æ‹³ï¼Œç„¶åæ¾å¼€ï¼Œå¹¶ä¸”ä¸Šæ¬¡ä¸æ˜¯é€šè¿‡æ¡æ‹³åˆ‡æ¢çš„çŠ¶æ€
                if (!isCurrentlyFist && this.wasFist && !this.lastState.startsWith('SWITCH_SHAPE_')) {
                    // æ¡æ‹³åŠ¨ä½œå®Œæˆï¼Œå¢åŠ è®¡æ•°å™¨å¹¶è§¦å‘å›¾å½¢åˆ‡æ¢
                    this.fistCount++;
                    newState = `SWITCH_SHAPE_${this.fistCount}`;
                } 
                // è®°å½•å½“å‰æ¡æ‹³çŠ¶æ€
                this.wasFist = isCurrentlyFist;
                
                // å¦‚æœæ²¡æœ‰æ£€æµ‹åˆ°æ¡æ‹³åˆ‡æ¢ï¼Œåˆ™ä½¿ç”¨åŸæ¥çš„çŠ¶æ€æ£€æµ‹
                if (newState === 'IDLE') {
                    if (this.isOpenHand(hand)) {
                        newState = 'OPEN';
                    } else if (isCurrentlyFist) {
                        newState = 'FIST';
                    }
                }
            }
        } else {
            // æ²¡æœ‰æ£€æµ‹åˆ°æ‰‹ï¼Œé‡ç½®æ¡æ‹³çŠ¶æ€
            this.wasFist = false;
        }

        if (newState !== this.lastState) {
            this.currentState = newState;
            this.lastState = newState;
            this.onStateChange(newState);
        }
    }
    
    // è®¡ç®—ä¼¸å‡ºçš„æ‰‹æŒ‡æ•°é‡ï¼ˆ1-5ï¼‰
    countExtendedFingers(landmarks) {
        let count = 0;
        
        // æ‰‹æŒ‡å°–ç«¯ç´¢å¼•ï¼šæ‹‡æŒ‡(4), é£ŸæŒ‡(8), ä¸­æŒ‡(12), æ— åæŒ‡(16), å°æŒ‡(20)
        const fingers = [
            { tip: 4, base: 2 },    // æ‹‡æŒ‡
            { tip: 8, base: 6 },    // é£ŸæŒ‡
            { tip: 12, base: 10 },  // ä¸­æŒ‡
            { tip: 16, base: 14 },  // æ— åæŒ‡
            { tip: 20, base: 18 }   // å°æŒ‡
        ];
        
        // ç‰¹æ®Šå¤„ç†æ‹‡æŒ‡ï¼ˆä½¿ç”¨ä¸é£ŸæŒ‡çš„è§’åº¦ï¼‰
        const thumbTip = landmarks[4];
        const indexTip = landmarks[8];
        const thumbBase = landmarks[2];
        const indexBase = landmarks[5];
        
        // è®¡ç®—æ‹‡æŒ‡æ˜¯å¦ä¼¸ç›´ï¼ˆåŸºäºä¸é£ŸæŒ‡çš„ç›¸å¯¹ä½ç½®ï¼‰
        const thumbToIndex = Math.sqrt(
            Math.pow(thumbTip.x - indexTip.x, 2) + 
            Math.pow(thumbTip.y - indexTip.y, 2)
        );
        const baseDistance = Math.sqrt(
            Math.pow(thumbBase.x - indexBase.x, 2) + 
            Math.pow(thumbBase.y - indexBase.y, 2)
        );
        const thumbExtended = thumbToIndex > baseDistance * 1.5;
        
        if (thumbExtended) count++;
        
        // å¤„ç†å…¶ä»–æ‰‹æŒ‡ï¼ˆé€šè¿‡æ¯”è¾ƒæŒ‡å°–ä¸æ‰‹æŒ‡ç¬¬äºŒå…³èŠ‚çš„ä½ç½®ï¼‰
        for (let i = 1; i < fingers.length; i++) {
            const tip = landmarks[fingers[i].tip];
            const base = landmarks[fingers[i].base];
            const baseMCP = landmarks[fingers[i].base - 3]; // æŒ‡æ ¹å…³èŠ‚
            
            // å¦‚æœæŒ‡å°–åœ¨Yè½´ä¸Šçš„ä½ç½®æ¯”ç¬¬äºŒå…³èŠ‚ä½ï¼Œè¡¨ç¤ºæ‰‹æŒ‡ä¼¸ç›´
            // æ³¨æ„ï¼šMediaPipeåæ ‡ç³»ä¸­ï¼ŒYè½´å‘ä¸‹ä¸ºæ­£
            if (tip.y < base.y) {
                count++;
            }
        }
        
        return count;
    }

    // ç®—æ³•ï¼šæ£€æµ‹æŒ‡å°–ä¸æ‰‹æŒåŸºéƒ¨çš„å¹³å‡è·ç¦»
    isFist(landmarks) {
        const wrist = landmarks[0];
        const tips = [8, 12, 16, 20]; // é™¤å»å¤§æ‹‡æŒ‡
        let avgDist = 0;
        
        tips.forEach(idx => {
            avgDist += this.getDistance(landmarks[idx], wrist);
        });
        avgDist /= 4;

        // å½’ä¸€åŒ–è·ç¦»ï¼ˆåŸºäºæ‰‹æŒå¤§å°åšå‚è€ƒï¼‰
        const palmSize = this.getDistance(landmarks[0], landmarks[9]);
        return (avgDist / palmSize) < 0.9; 
    }

    isOpenHand(landmarks) {
        const wrist = landmarks[0];
        const tips = [8, 12, 16, 20];
        let avgDist = 0;
        tips.forEach(idx => {
            avgDist += this.getDistance(landmarks[idx], wrist);
        });
        avgDist /= 4;
        
        const palmSize = this.getDistance(landmarks[0], landmarks[9]);
        return (avgDist / palmSize) > 1.4;
    }

    // ç®—æ³•ï¼šæ£€æµ‹ä¸¤åªæ‰‹è…•è·ç¦»æ˜¯å¦å¾ˆè¿‘
    isHandsTogether(hand1, hand2) {
        const dist = this.getDistance(hand1[0], hand2[0]); // Wrist distance
        return dist < 0.2; // é˜ˆå€¼ï¼Œéœ€æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´
    }

    getDistance(p1, p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    }
}

/**
 * æ¨¡å—ä¸‰ï¼šUI ä¸ä¸»é€»è¾‘ç»‘å®š (Main & UI)
 */
document.addEventListener('DOMContentLoaded', () => {
    // 1. åˆå§‹åŒ– 3D ä¸–ç•Œ
    const container = document.getElementById('canvas-container');
    const world = new ParticleWorld(container);

    // 2. UI å…ƒç´ 
    const uiStatus = document.getElementById('status-display');
    const colorPicker = document.getElementById('color-picker');
    const fullScreenBtn = document.getElementById('fullscreen-btn');

    // 3. æ‰‹åŠ¿å›è°ƒ
    const handleGesture = (state) => {
        let text = "";
        
        // å¤„ç†å½¢çŠ¶åˆ‡æ¢çŠ¶æ€
        if (state.startsWith('SWITCH_SHAPE_')) {
            const switchCount = parseInt(state.split('_')[2]);
            // å®šä¹‰å½¢çŠ¶åç§°æ˜ å°„ï¼ŒåŒ…å«æ–°å¢å›¾å½¢
            const shapeNames = {
                0: 'å›¾è…¾',
                1: 'åœ†ç¯',
                2: 'åœ†æŸ±ä½“',
                3: 'ç«‹æ–¹ä½“',
                4: 'çƒä½“',
                5: 'æ˜Ÿå½¢',
                6: 'åœ†é”¥ä½“',
                7: 'å››é¢ä½“',
                8: 'åŒæ›²çº¿'
            };
            // è®¡ç®—å½“å‰å½¢çŠ¶ç´¢å¼•
            const shapeIndex = (switchCount - 1) % 9;
            
            text = `âœŠ æ¡æ‹³åˆ‡æ¢ - ${shapeNames[shapeIndex]}`;
        } else {
            // å¤„ç†æ‰‹åŠ¿çŠ¶æ€
            switch(state) {
                case 'FIST':
                    text = 'âœŠ æ¡æ‹³ä¸­... (æ¾å¼€å®Œæˆåˆ‡æ¢)';
                    break;
                case 'OPEN':
                    text = 'ğŸ–ï¸ æ‰‹æŒå¼ å¼€';
                    break;
                case 'MAGIC':
                    text = 'ğŸ¤ åŒæ‰‹åˆä¸€ - é­”æ³•æ¨¡å¼';
                    break;
                default:
                    text = 'ğŸ‘ˆ è¯·å°†æ‰‹æ”¾åœ¨æ‘„åƒå¤´å‰';
            }
        }
        
        uiStatus.innerText = text;
        world.setInteractionState(state);
    };

    // 4. å¯åŠ¨æ‰‹åŠ¿è¿½è¸ª
    const videoElement = document.getElementById('input-video');
    const tracker = new HandController(videoElement, handleGesture);
    tracker.start();

    // 5. ç»‘å®š UI äº‹ä»¶
    colorPicker.addEventListener('input', (e) => {
        world.setColor(e.target.value);
    });

    fullScreenBtn.addEventListener('click', () => {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
            fullScreenBtn.innerText = "é€€å‡ºå…¨å±";
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
                fullScreenBtn.innerText = "åˆ‡æ¢å…¨å±æ²‰æµ¸æ¨¡å¼";
            }
        }
    });
});

</script>
</body>
</html>
